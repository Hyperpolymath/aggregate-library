{
  "$schema": "./schema.json",
  "schema_version": "1.1.0",
  "generated_at": "2025-12-27",
  "metadata": {
    "name": "aLib Common Library Aggregate",
    "description": "Aggregated dataset of all operation specifications for cross-language programming",
    "total_operations": 20,
    "categories": ["arithmetic", "comparison", "logical", "string", "collection", "conditional"]
  },
  "provenance": {
    "repository": "https://github.com/hyperpolymath/aggregate-library",
    "license": "MIT OR Palimpsest-0.8",
    "contributors": [
      { "name": "Hyperpolymath", "role": "maintainer", "contact": "https://github.com/hyperpolymath" }
    ],
    "created_at": "2025-12-27",
    "modified_at": "2025-12-27",
    "derivation": "extracted",
    "source_description": "Aggregated from individual spec files in specs/ directory"
  },
  "operations": [
    {
      "name": "add",
      "category": "arithmetic",
      "signature_string": "add: Number, Number -> Number",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Number" }
      },
      "semantics": {
        "purpose": "Computes the sum of two numbers.",
        "parameters": [
          { "name": "a", "description": "The first number (augend)" },
          { "name": "b", "description": "The second number (addend)" }
        ],
        "return_value": "The arithmetic sum of a and b.",
        "properties": [
          { "name": "Commutative", "expression": "add(a, b) = add(b, a)" },
          { "name": "Associative", "expression": "add(add(a, b), c) = add(a, add(b, c))" },
          { "name": "Identity element", "expression": "add(a, 0) = a" }
        ],
        "edge_cases": [
          "Overflow/underflow behavior is implementation-defined",
          "NaN and infinity handling is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [2, 3], "output": 5, "description": "Basic addition of positive integers" },
        { "input": [-5, 3], "output": -2, "description": "Addition with negative number" },
        { "input": [0, 0], "output": 0, "description": "Addition of zeros" },
        { "input": [1.5, 2.5], "output": 4.0, "description": "Addition of decimal numbers" },
        { "input": [-10, -20], "output": -30, "description": "Addition of two negative numbers" }
      ],
      "provenance": {
        "source_file": "specs/arithmetic/add.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "subtract",
      "category": "arithmetic",
      "signature_string": "subtract: Number, Number -> Number",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Number" }
      },
      "semantics": {
        "purpose": "Computes the difference between two numbers.",
        "parameters": [
          { "name": "a", "description": "The minuend (number from which another is subtracted)" },
          { "name": "b", "description": "The subtrahend (number to be subtracted)" }
        ],
        "return_value": "The arithmetic difference a - b.",
        "properties": [
          { "name": "Non-commutative", "expression": "subtract(a, b) != subtract(b, a)" },
          { "name": "Identity element", "expression": "subtract(a, 0) = a" },
          { "name": "Inverse of addition", "expression": "subtract(add(a, b), b) = a" }
        ],
        "edge_cases": [
          "Overflow/underflow behavior is implementation-defined",
          "NaN and infinity handling is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [5, 3], "output": 2, "description": "Basic subtraction of positive integers" },
        { "input": [3, 5], "output": -2, "description": "Subtraction resulting in negative number" },
        { "input": [0, 0], "output": 0, "description": "Subtraction of zeros" },
        { "input": [-5, 3], "output": -8, "description": "Subtracting positive from negative" },
        { "input": [10.5, 2.5], "output": 8.0, "description": "Subtraction of decimal numbers" },
        { "input": [-10, -20], "output": 10, "description": "Subtracting negative from negative" }
      ],
      "provenance": {
        "source_file": "specs/arithmetic/subtract.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "multiply",
      "category": "arithmetic",
      "signature_string": "multiply: Number, Number -> Number",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Number" }
      },
      "semantics": {
        "purpose": "Computes the product of two numbers.",
        "parameters": [
          { "name": "a", "description": "The multiplicand (first factor)" },
          { "name": "b", "description": "The multiplier (second factor)" }
        ],
        "return_value": "The arithmetic product a * b.",
        "properties": [
          { "name": "Commutative", "expression": "multiply(a, b) = multiply(b, a)" },
          { "name": "Associative", "expression": "multiply(multiply(a, b), c) = multiply(a, multiply(b, c))" },
          { "name": "Identity element", "expression": "multiply(a, 1) = a" },
          { "name": "Zero property", "expression": "multiply(a, 0) = 0" },
          { "name": "Distributive over addition", "expression": "multiply(a, add(b, c)) = add(multiply(a, b), multiply(a, c))" }
        ],
        "edge_cases": [
          "Overflow/underflow behavior is implementation-defined",
          "NaN and infinity handling is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [2, 3], "output": 6, "description": "Basic multiplication of positive integers" },
        { "input": [-5, 3], "output": -15, "description": "Multiplication with negative number" },
        { "input": [0, 42], "output": 0, "description": "Multiplication by zero" },
        { "input": [7, 1], "output": 7, "description": "Multiplication by one (identity)" },
        { "input": [2.5, 4], "output": 10.0, "description": "Multiplication with decimal number" },
        { "input": [-3, -4], "output": 12, "description": "Multiplication of two negative numbers" }
      ],
      "provenance": {
        "source_file": "specs/arithmetic/multiply.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "divide",
      "category": "arithmetic",
      "signature_string": "divide: Number, Number -> Number",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Number" }
      },
      "semantics": {
        "purpose": "Computes the quotient of two numbers.",
        "parameters": [
          { "name": "a", "description": "The dividend (number to be divided)" },
          { "name": "b", "description": "The divisor (number by which to divide)" }
        ],
        "return_value": "The arithmetic quotient a / b.",
        "properties": [
          { "name": "Non-commutative", "expression": "divide(a, b) != divide(b, a)" },
          { "name": "Identity element", "expression": "divide(a, 1) = a" },
          { "name": "Inverse of multiplication", "expression": "divide(multiply(a, b), b) = a when b != 0" }
        ],
        "edge_cases": [
          "Division by zero is implementation-defined",
          "Integer vs floating-point division is implementation-defined",
          "Overflow/underflow behavior is implementation-defined",
          "NaN and infinity handling is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [6, 2], "output": 3, "description": "Basic division with exact result" },
        { "input": [7, 2], "output": 3.5, "description": "Division with fractional result" },
        { "input": [0, 5], "output": 0, "description": "Zero divided by non-zero" },
        { "input": [-10, 2], "output": -5, "description": "Division with negative dividend" },
        { "input": [10, -2], "output": -5, "description": "Division with negative divisor" },
        { "input": [-12, -3], "output": 4, "description": "Division of two negative numbers" }
      ],
      "provenance": {
        "source_file": "specs/arithmetic/divide.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "modulo",
      "category": "arithmetic",
      "signature_string": "modulo: Number, Number -> Number",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Number" }
      },
      "semantics": {
        "purpose": "Computes the remainder of division of two numbers.",
        "parameters": [
          { "name": "a", "description": "The dividend (number to be divided)" },
          { "name": "b", "description": "The divisor (number by which to divide)" }
        ],
        "return_value": "The remainder when a is divided by b.",
        "properties": [
          { "name": "Non-commutative", "expression": "modulo(a, b) != modulo(b, a)" },
          { "name": "Range bound", "expression": "0 <= modulo(a, b) < b when b > 0" }
        ],
        "edge_cases": [
          "Modulo by zero is implementation-defined",
          "Sign of result with negative operands is implementation-defined",
          "Behavior with floating-point numbers is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [7, 3], "output": 1, "description": "Basic modulo with positive integers" },
        { "input": [10, 5], "output": 0, "description": "Modulo with no remainder" },
        { "input": [15, 4], "output": 3, "description": "Modulo returning non-zero remainder" },
        { "input": [0, 5], "output": 0, "description": "Zero modulo non-zero" },
        { "input": [100, 7], "output": 2, "description": "Modulo with larger numbers" }
      ],
      "provenance": {
        "source_file": "specs/arithmetic/modulo.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "less_than",
      "category": "comparison",
      "signature_string": "less_than: Number, Number -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Determines if the first number is strictly less than the second.",
        "parameters": [
          { "name": "a", "description": "The first number to compare" },
          { "name": "b", "description": "The second number to compare" }
        ],
        "return_value": "true if a < b, otherwise false.",
        "properties": [
          { "name": "Irreflexive", "expression": "less_than(a, a) = false" },
          { "name": "Asymmetric", "expression": "if less_than(a, b) then not(less_than(b, a))" },
          { "name": "Transitive", "expression": "if less_than(a, b) and less_than(b, c) then less_than(a, c)" }
        ],
        "edge_cases": [
          "Floating-point precision issues are implementation-defined",
          "NaN comparisons are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [3, 5], "output": true, "description": "3 is less than 5" },
        { "input": [5, 3], "output": false, "description": "5 is not less than 3" },
        { "input": [5, 5], "output": false, "description": "Equal values are not less than" },
        { "input": [-5, 0], "output": true, "description": "Negative is less than zero" },
        { "input": [2.5, 3.5], "output": true, "description": "Decimal comparison" }
      ],
      "provenance": {
        "source_file": "specs/comparison/less_than.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "greater_than",
      "category": "comparison",
      "signature_string": "greater_than: Number, Number -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Determines if the first number is strictly greater than the second.",
        "parameters": [
          { "name": "a", "description": "The first number to compare" },
          { "name": "b", "description": "The second number to compare" }
        ],
        "return_value": "true if a > b, otherwise false.",
        "properties": [
          { "name": "Irreflexive", "expression": "greater_than(a, a) = false" },
          { "name": "Asymmetric", "expression": "if greater_than(a, b) then not(greater_than(b, a))" },
          { "name": "Transitive", "expression": "if greater_than(a, b) and greater_than(b, c) then greater_than(a, c)" }
        ],
        "edge_cases": [
          "Floating-point precision issues are implementation-defined",
          "NaN comparisons are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [5, 3], "output": true, "description": "5 is greater than 3" },
        { "input": [3, 5], "output": false, "description": "3 is not greater than 5" },
        { "input": [5, 5], "output": false, "description": "Equal values are not greater than" },
        { "input": [0, -5], "output": true, "description": "Zero is greater than negative" },
        { "input": [3.5, 2.5], "output": true, "description": "Decimal comparison" }
      ],
      "provenance": {
        "source_file": "specs/comparison/greater_than.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "equal",
      "category": "comparison",
      "signature_string": "equal: Number, Number -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Determines if two numbers are equal in value.",
        "parameters": [
          { "name": "a", "description": "The first number to compare" },
          { "name": "b", "description": "The second number to compare" }
        ],
        "return_value": "true if a equals b, otherwise false.",
        "properties": [
          { "name": "Reflexive", "expression": "equal(a, a) = true" },
          { "name": "Symmetric", "expression": "equal(a, b) = equal(b, a)" },
          { "name": "Transitive", "expression": "if equal(a, b) and equal(b, c) then equal(a, c)" }
        ],
        "edge_cases": [
          "Floating-point precision issues are implementation-defined",
          "NaN equality (typically NaN != NaN) is implementation-defined",
          "Positive and negative zero equality is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [5, 5], "output": true, "description": "Equal positive integers" },
        { "input": [5, 3], "output": false, "description": "Unequal positive integers" },
        { "input": [0, 0], "output": true, "description": "Zero equals zero" },
        { "input": [-5, -5], "output": true, "description": "Equal negative integers" },
        { "input": [-5, 5], "output": false, "description": "Negative and positive not equal" },
        { "input": [2.5, 2.5], "output": true, "description": "Equal decimal numbers" },
        { "input": [1.0, 1], "output": true, "description": "Decimal and integer with same value" }
      ],
      "provenance": {
        "source_file": "specs/comparison/equal.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "not_equal",
      "category": "comparison",
      "signature_string": "not_equal: Number, Number -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Determines if two numbers are not equal in value.",
        "parameters": [
          { "name": "a", "description": "The first number to compare" },
          { "name": "b", "description": "The second number to compare" }
        ],
        "return_value": "true if a does not equal b, otherwise false.",
        "properties": [
          { "name": "Negation of equal", "expression": "not_equal(a, b) = not(equal(a, b))" },
          { "name": "Symmetric", "expression": "not_equal(a, b) = not_equal(b, a)" }
        ],
        "edge_cases": [
          "Floating-point precision issues are implementation-defined",
          "NaN comparisons are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [5, 3], "output": true, "description": "Unequal positive integers" },
        { "input": [5, 5], "output": false, "description": "Equal values return false" },
        { "input": [-5, 5], "output": true, "description": "Negative and positive are not equal" },
        { "input": [0, 0], "output": false, "description": "Zero equals zero" }
      ],
      "provenance": {
        "source_file": "specs/comparison/not_equal.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "less_equal",
      "category": "comparison",
      "signature_string": "less_equal: Number, Number -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Determines if the first number is less than or equal to the second.",
        "parameters": [
          { "name": "a", "description": "The first number to compare" },
          { "name": "b", "description": "The second number to compare" }
        ],
        "return_value": "true if a <= b, otherwise false.",
        "properties": [
          { "name": "Reflexive", "expression": "less_equal(a, a) = true" },
          { "name": "Antisymmetric", "expression": "if less_equal(a, b) and less_equal(b, a) then equal(a, b)" },
          { "name": "Transitive", "expression": "if less_equal(a, b) and less_equal(b, c) then less_equal(a, c)" }
        ],
        "edge_cases": [
          "Floating-point precision issues are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [3, 5], "output": true, "description": "3 is less than or equal to 5" },
        { "input": [5, 5], "output": true, "description": "Equal values return true" },
        { "input": [5, 3], "output": false, "description": "5 is not less than or equal to 3" },
        { "input": [-5, 0], "output": true, "description": "Negative is less than or equal to zero" }
      ],
      "provenance": {
        "source_file": "specs/comparison/less_equal.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "greater_equal",
      "category": "comparison",
      "signature_string": "greater_equal: Number, Number -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Determines if the first number is greater than or equal to the second.",
        "parameters": [
          { "name": "a", "description": "The first number to compare" },
          { "name": "b", "description": "The second number to compare" }
        ],
        "return_value": "true if a >= b, otherwise false.",
        "properties": [
          { "name": "Reflexive", "expression": "greater_equal(a, a) = true" },
          { "name": "Antisymmetric", "expression": "if greater_equal(a, b) and greater_equal(b, a) then equal(a, b)" },
          { "name": "Transitive", "expression": "if greater_equal(a, b) and greater_equal(b, c) then greater_equal(a, c)" }
        ],
        "edge_cases": [
          "Floating-point precision issues are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [5, 3], "output": true, "description": "5 is greater than or equal to 3" },
        { "input": [5, 5], "output": true, "description": "Equal values return true" },
        { "input": [3, 5], "output": false, "description": "3 is not greater than or equal to 5" },
        { "input": [0, -5], "output": true, "description": "Zero is greater than or equal to negative" }
      ],
      "provenance": {
        "source_file": "specs/comparison/greater_equal.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "and",
      "category": "logical",
      "signature_string": "and: Boolean, Boolean -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Boolean" },
          { "base": "Boolean" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Performs logical conjunction of two boolean values.",
        "parameters": [
          { "name": "a", "description": "The first boolean value" },
          { "name": "b", "description": "The second boolean value" }
        ],
        "return_value": "true if both a and b are true, otherwise false.",
        "properties": [
          { "name": "Commutative", "expression": "and(a, b) = and(b, a)" },
          { "name": "Associative", "expression": "and(and(a, b), c) = and(a, and(b, c))" },
          { "name": "Identity element", "expression": "and(a, true) = a" },
          { "name": "Annihilator element", "expression": "and(a, false) = false" },
          { "name": "Idempotent", "expression": "and(a, a) = a" },
          { "name": "Distributive over or", "expression": "and(a, or(b, c)) = or(and(a, b), and(a, c))" }
        ],
        "edge_cases": [
          "Short-circuit evaluation is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [true, true], "output": true, "description": "Both values are true" },
        { "input": [true, false], "output": false, "description": "First is true, second is false" },
        { "input": [false, true], "output": false, "description": "First is false, second is true" },
        { "input": [false, false], "output": false, "description": "Both values are false" }
      ],
      "provenance": {
        "source_file": "specs/logical/and.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "or",
      "category": "logical",
      "signature_string": "or: Boolean, Boolean -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Boolean" },
          { "base": "Boolean" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Performs logical disjunction of two boolean values.",
        "parameters": [
          { "name": "a", "description": "The first boolean value" },
          { "name": "b", "description": "The second boolean value" }
        ],
        "return_value": "true if at least one of a or b is true, otherwise false.",
        "properties": [
          { "name": "Commutative", "expression": "or(a, b) = or(b, a)" },
          { "name": "Associative", "expression": "or(or(a, b), c) = or(a, or(b, c))" },
          { "name": "Identity element", "expression": "or(a, false) = a" },
          { "name": "Annihilator element", "expression": "or(a, true) = true" },
          { "name": "Idempotent", "expression": "or(a, a) = a" },
          { "name": "Distributive over and", "expression": "or(a, and(b, c)) = and(or(a, b), or(a, c))" }
        ],
        "edge_cases": [
          "Short-circuit evaluation is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": [true, true], "output": true, "description": "Both values are true" },
        { "input": [true, false], "output": true, "description": "First is true, second is false" },
        { "input": [false, true], "output": true, "description": "First is false, second is true" },
        { "input": [false, false], "output": false, "description": "Both values are false" }
      ],
      "provenance": {
        "source_file": "specs/logical/or.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "not",
      "category": "logical",
      "signature_string": "not: Boolean -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Boolean" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Performs logical negation of a boolean value.",
        "parameters": [
          { "name": "a", "description": "The boolean value to negate" }
        ],
        "return_value": "true if a is false, false if a is true.",
        "properties": [
          { "name": "Involution", "expression": "not(not(a)) = a" },
          { "name": "De Morgan's laws", "expression": "not(and(a, b)) = or(not(a), not(b))" }
        ],
        "edge_cases": []
      },
      "test_cases": [
        { "input": [true], "output": false, "description": "Negation of true is false" },
        { "input": [false], "output": true, "description": "Negation of false is true" }
      ],
      "provenance": {
        "source_file": "specs/logical/not.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "concat",
      "category": "string",
      "signature_string": "concat: String, String -> String",
      "signature": {
        "inputs": [
          { "base": "String" },
          { "base": "String" }
        ],
        "output": { "base": "String" }
      },
      "semantics": {
        "purpose": "Concatenates two strings together, forming a new string.",
        "parameters": [
          { "name": "a", "description": "The first string" },
          { "name": "b", "description": "The second string" }
        ],
        "return_value": "A new string consisting of all characters from a followed by all characters from b.",
        "properties": [
          { "name": "Associative", "expression": "concat(concat(a, b), c) = concat(a, concat(b, c))" },
          { "name": "Identity element", "expression": "concat(a, \"\") = concat(\"\", a) = a" },
          { "name": "Non-commutative", "expression": "concat(a, b) != concat(b, a)" }
        ],
        "edge_cases": [
          "Concatenating empty strings returns the other string",
          "String encoding/character set handling is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": ["hello", "world"], "output": "helloworld", "description": "Basic string concatenation" },
        { "input": ["hello", " world"], "output": "hello world", "description": "Concatenation with space" },
        { "input": ["", "test"], "output": "test", "description": "Concatenation with empty string (left)" },
        { "input": ["test", ""], "output": "test", "description": "Concatenation with empty string (right)" },
        { "input": ["", ""], "output": "", "description": "Concatenation of two empty strings" },
        { "input": ["123", "456"], "output": "123456", "description": "Concatenation of numeric strings" }
      ],
      "provenance": {
        "source_file": "specs/string/concat.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "length",
      "category": "string",
      "signature_string": "length: String -> Number",
      "signature": {
        "inputs": [
          { "base": "String" }
        ],
        "output": { "base": "Number" }
      },
      "semantics": {
        "purpose": "Returns the number of characters in a string.",
        "parameters": [
          { "name": "s", "description": "The string to measure" }
        ],
        "return_value": "The count of characters in the string.",
        "properties": [
          { "name": "Non-negative", "expression": "length(s) >= 0" },
          { "name": "Empty string", "expression": "length(\"\") = 0" },
          { "name": "Concatenation", "expression": "length(concat(a, b)) = add(length(a), length(b))" }
        ],
        "edge_cases": [
          "Unicode character counting is implementation-defined",
          "Multi-byte character handling is implementation-defined"
        ]
      },
      "test_cases": [
        { "input": ["hello"], "output": 5, "description": "Length of basic string" },
        { "input": [""], "output": 0, "description": "Length of empty string" },
        { "input": [" "], "output": 1, "description": "Length of single space" },
        { "input": ["hello world"], "output": 11, "description": "Length with space" }
      ],
      "provenance": {
        "source_file": "specs/string/length.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "substring",
      "category": "string",
      "signature_string": "substring: String, Number, Number -> String",
      "signature": {
        "inputs": [
          { "base": "String" },
          { "base": "Number" },
          { "base": "Number" }
        ],
        "output": { "base": "String" }
      },
      "semantics": {
        "purpose": "Extracts a portion of a string between specified indices.",
        "parameters": [
          { "name": "s", "description": "The source string" },
          { "name": "start", "description": "The starting index (0-based, inclusive)" },
          { "name": "end", "description": "The ending index (exclusive)" }
        ],
        "return_value": "A new string containing characters from index start to end-1.",
        "properties": [
          { "name": "Empty range", "expression": "substring(s, i, i) = \"\"" },
          { "name": "Full string", "expression": "substring(s, 0, length(s)) = s" }
        ],
        "edge_cases": [
          "Out of bounds indices are implementation-defined",
          "Negative indices are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": ["hello", 0, 2], "output": "he", "description": "First two characters" },
        { "input": ["hello", 1, 4], "output": "ell", "description": "Middle portion" },
        { "input": ["hello", 0, 5], "output": "hello", "description": "Full string" },
        { "input": ["hello", 2, 2], "output": "", "description": "Empty range" }
      ],
      "provenance": {
        "source_file": "specs/string/substring.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "map",
      "category": "collection",
      "signature_string": "map: Collection[A], Function[A -> B] -> Collection[B]",
      "signature": {
        "inputs": [
          { "base": "Collection", "collection_of": "A" },
          { "base": "Function", "function": { "input": "A", "output": "B" } }
        ],
        "output": { "base": "Collection", "collection_of": "B" }
      },
      "semantics": {
        "purpose": "Transforms each element of a collection by applying a function, producing a new collection of the same length.",
        "parameters": [
          { "name": "collection", "description": "The source collection of elements of type A" },
          { "name": "fn", "description": "A function that transforms elements from type A to type B" }
        ],
        "return_value": "A new collection containing the results of applying fn to each element in collection, preserving order.",
        "properties": [
          { "name": "Preserves length", "expression": "length(map(c, fn)) = length(c)" },
          { "name": "Preserves order", "expression": "Elements appear in the same order as source collection" },
          { "name": "Identity", "expression": "map(c, identity) = c" },
          { "name": "Composition", "expression": "map(map(c, f), g) = map(c, compose(g, f))" },
          { "name": "Empty collection", "expression": "map([], fn) = []" }
        ],
        "edge_cases": [
          "Lazy vs eager evaluation is implementation-defined",
          "Side effects in the function are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": { "collection": [1, 2, 3], "fn": "x => multiply(x, 2)" }, "output": [2, 4, 6], "description": "Double each number in collection" },
        { "input": { "collection": [1, 2, 3], "fn": "x => add(x, 10)" }, "output": [11, 12, 13], "description": "Add 10 to each number" },
        { "input": { "collection": [], "fn": "x => multiply(x, 2)" }, "output": [], "description": "Mapping over empty collection returns empty collection" },
        { "input": { "collection": [5], "fn": "x => x" }, "output": [5], "description": "Identity function returns same element" },
        { "input": { "collection": ["a", "b", "c"], "fn": "s => concat(s, s)" }, "output": ["aa", "bb", "cc"], "description": "Map over string collection" }
      ],
      "provenance": {
        "source_file": "specs/collection/map.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "filter",
      "category": "collection",
      "signature_string": "filter: Collection[A], Function[A -> Boolean] -> Collection[A]",
      "signature": {
        "inputs": [
          { "base": "Collection", "collection_of": "A" },
          { "base": "Function", "function": { "input": "A", "output": "Boolean" } }
        ],
        "output": { "base": "Collection", "collection_of": "A" }
      },
      "semantics": {
        "purpose": "Selects elements from a collection that satisfy a predicate function, producing a new collection.",
        "parameters": [
          { "name": "collection", "description": "The source collection of elements of type A" },
          { "name": "predicate", "description": "A function that returns true for elements to keep, false for elements to exclude" }
        ],
        "return_value": "A new collection containing only the elements from collection for which predicate returns true, preserving original order.",
        "properties": [
          { "name": "Length bound", "expression": "length(filter(c, p)) <= length(c)" },
          { "name": "Preserves order", "expression": "Elements appear in same relative order as in source" },
          { "name": "Always true predicate", "expression": "filter(c, always_true) = c" },
          { "name": "Always false predicate", "expression": "filter(c, always_false) = []" },
          { "name": "Empty collection", "expression": "filter([], p) = []" },
          { "name": "Composition", "expression": "filter(filter(c, p1), p2) = filter(c, x => and(p1(x), p2(x)))" }
        ],
        "edge_cases": [
          "Lazy vs eager evaluation is implementation-defined",
          "Side effects in the predicate are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": { "collection": [1, 2, 3, 4, 5], "predicate": "x => greater_than(x, 2)" }, "output": [3, 4, 5], "description": "Filter numbers greater than 2" },
        { "input": { "collection": [1, 2, 3, 4, 5], "predicate": "x => equal(modulo(x, 2), 0)" }, "output": [2, 4], "description": "Filter even numbers" },
        { "input": { "collection": [1, 2, 3], "predicate": "x => true" }, "output": [1, 2, 3], "description": "Filter with always-true predicate returns all elements" },
        { "input": { "collection": [1, 2, 3], "predicate": "x => false" }, "output": [], "description": "Filter with always-false predicate returns empty collection" },
        { "input": { "collection": [], "predicate": "x => true" }, "output": [], "description": "Filter empty collection returns empty collection" }
      ],
      "provenance": {
        "source_file": "specs/collection/filter.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "fold",
      "category": "collection",
      "signature_string": "fold: Collection[A], B, Function[B, A -> B] -> B",
      "signature": {
        "inputs": [
          { "base": "Collection", "collection_of": "A" },
          { "base": "B", "generic": "B" },
          { "base": "Function", "function": { "input": "B, A", "output": "B" } }
        ],
        "output": { "base": "B", "generic": "B" }
      },
      "semantics": {
        "purpose": "Reduces a collection to a single value by iteratively applying a combining function.",
        "parameters": [
          { "name": "collection", "description": "The source collection of elements of type A" },
          { "name": "initial", "description": "The initial accumulator value of type B" },
          { "name": "fn", "description": "A function that combines the accumulator with each element" }
        ],
        "return_value": "The final accumulated value after processing all elements.",
        "properties": [
          { "name": "Empty collection", "expression": "fold([], initial, fn) = initial" },
          { "name": "Single element", "expression": "fold([x], initial, fn) = fn(initial, x)" }
        ],
        "edge_cases": [
          "Left vs right fold is implementation-defined",
          "Side effects in the function are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": { "collection": [1, 2, 3, 4], "initial": 0, "fn": "acc, x => add(acc, x)" }, "output": 10, "description": "Sum all numbers" },
        { "input": { "collection": [1, 2, 3, 4], "initial": 1, "fn": "acc, x => multiply(acc, x)" }, "output": 24, "description": "Product of all numbers" },
        { "input": { "collection": [], "initial": 0, "fn": "acc, x => add(acc, x)" }, "output": 0, "description": "Fold over empty collection returns initial value" },
        { "input": { "collection": ["a", "b", "c"], "initial": "", "fn": "acc, x => concat(acc, x)" }, "output": "abc", "description": "Concatenate strings" }
      ],
      "provenance": {
        "source_file": "specs/collection/fold.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "contains",
      "category": "collection",
      "signature_string": "contains: Collection[A], A -> Boolean",
      "signature": {
        "inputs": [
          { "base": "Collection", "collection_of": "A" },
          { "base": "A", "generic": "A" }
        ],
        "output": { "base": "Boolean" }
      },
      "semantics": {
        "purpose": "Checks if a collection contains a specific element.",
        "parameters": [
          { "name": "collection", "description": "The collection to search" },
          { "name": "element", "description": "The element to find" }
        ],
        "return_value": "true if the element exists in the collection, otherwise false.",
        "properties": [
          { "name": "Empty collection", "expression": "contains([], x) = false" },
          { "name": "Single match", "expression": "contains([x], x) = true" }
        ],
        "edge_cases": [
          "Equality comparison semantics are implementation-defined"
        ]
      },
      "test_cases": [
        { "input": { "collection": [1, 2, 3], "element": 2 }, "output": true, "description": "Element exists in collection" },
        { "input": { "collection": [1, 2, 3], "element": 4 }, "output": false, "description": "Element does not exist" },
        { "input": { "collection": [], "element": 1 }, "output": false, "description": "Empty collection contains nothing" },
        { "input": { "collection": ["a", "b", "c"], "element": "b" }, "output": true, "description": "String element exists" }
      ],
      "provenance": {
        "source_file": "specs/collection/contains.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    },
    {
      "name": "if_then_else",
      "category": "conditional",
      "signature_string": "if_then_else: Boolean, A, A -> A",
      "signature": {
        "inputs": [
          { "base": "Boolean" },
          { "base": "A", "generic": "A" },
          { "base": "A", "generic": "A" }
        ],
        "output": { "base": "A", "generic": "A" }
      },
      "semantics": {
        "purpose": "Selects one of two values based on a boolean condition.",
        "parameters": [
          { "name": "condition", "description": "A boolean value determining which branch to take" },
          { "name": "then_value", "description": "The value to return if condition is true" },
          { "name": "else_value", "description": "The value to return if condition is false" }
        ],
        "return_value": "then_value if condition is true, otherwise else_value.",
        "properties": [
          { "name": "True branch", "expression": "if_then_else(true, a, b) = a" },
          { "name": "False branch", "expression": "if_then_else(false, a, b) = b" },
          { "name": "Same values", "expression": "if_then_else(c, a, a) = a" },
          { "name": "Boolean and", "expression": "and(a, b) = if_then_else(a, b, false)" },
          { "name": "Boolean or", "expression": "or(a, b) = if_then_else(a, true, b)" },
          { "name": "Boolean not", "expression": "not(a) = if_then_else(a, false, true)" }
        ],
        "edge_cases": [
          "Evaluation strategy (strict vs lazy) is implementation-defined",
          "Languages may provide this as a statement/keyword rather than a function"
        ]
      },
      "test_cases": [
        { "input": { "condition": true, "then_value": 10, "else_value": 20 }, "output": 10, "description": "Condition is true, return then_value" },
        { "input": { "condition": false, "then_value": 10, "else_value": 20 }, "output": 20, "description": "Condition is false, return else_value" },
        { "input": { "condition": true, "then_value": "yes", "else_value": "no" }, "output": "yes", "description": "Works with string values" },
        { "input": { "condition": false, "then_value": "yes", "else_value": "no" }, "output": "no", "description": "Returns else branch for false condition" }
      ],
      "provenance": {
        "source_file": "specs/conditional/if_then_else.md",
        "repository": "https://github.com/hyperpolymath/aggregate-library",
        "license": "MIT OR Palimpsest-0.8",
        "contributors": [{ "name": "Hyperpolymath", "role": "author" }],
        "created_at": "2025-11-22",
        "modified_at": "2025-12-27",
        "derivation": "extracted"
      },
      "version": "1.0.0"
    }
  ]
}
